========================================
카카오톡 공유 관련 HTML 코드
========================================

[1] generateSummaryText() - 텍스트 요약 생성 함수
========================================
function generateSummaryText() {
    let text = `📊 ${currentSiteName}\n`;
    text += `${new Date().toLocaleDateString('ko-KR')} (로스율 ${Math.round(currentLossRate * 100)}%)\n\n`;
    
    // 석고보드 종류별 집계
    const groupedByType = {};
    const groupedByWood = {};
    const groupedBySteel = {};
    
    walls.forEach(wall => {
        if (wall.width && wall.height) {
            const area = (wall.width * wall.height) / 1000000;
            const boardArea = getBoardArea(wall.boardSize);
            let boards = (area / boardArea);
            boards *= (wall.constructionSide === '2P' ? 2 : 1);
            boards *= (wall.faceDirection === '양면' ? 2 : 1);
            boards *= (1 + currentLossRate);
            const finalBoards = Math.ceil(boards);
            
            // 석고보드 집계
            const boardKey = `${wall.boardType}-${wall.boardSize}-${wall.boardThickness}`;
            if (!groupedByType[boardKey]) {
                groupedByType[boardKey] = {
                    type: wall.boardType,
                    size: wall.boardSize,
                    thickness: wall.boardThickness,
                    totalBoards: 0
                };
            }
            groupedByType[boardKey].totalBoards += finalBoards;
            
            // 목자재 집계
            if (wall.joistType === '목자재') {
                const joistKey = wall.woodType;
                if (!groupedByWood[joistKey]) {
                    let woodName = wall.woodType;
                    let woodSize = '';
                    if (wall.woodType === '한치각') {
                        woodName = '한치각';
                        woodSize = '30×30';
                    } else if (wall.woodType === '한치각반') {
                        woodName = '한치각반';
                        woodSize = '30×45';
                    } else if (wall.woodType.includes('SPF')) {
                        woodName = wall.woodType;
                        woodSize = '38×89';
                    } else if (wall.woodType.includes('×')) {
                        const parts = wall.woodType.split(' ');
                        woodName = parts[0];
                        woodSize = parts[0];
                    } else {
                        woodName = wall.woodType;
                        woodSize = '';
                    }
                    
                    groupedByWood[joistKey] = { 
                        name: woodName,
                        size: woodSize,
                        count: 0 
                    };
                }
                const verticalCount = Math.floor(wall.width / wall.joistSpacing) + 1;
                const horizontal = Math.ceil(wall.width / 2700) * 2;
                let total = verticalCount + horizontal;
                total *= (wall.faceDirection === '양면' ? 2 : 1);
                groupedByWood[joistKey].count += Math.ceil(total * (1 + currentLossRate));
            }
            
            // 경량철골 집계
            if (wall.joistType === '경량철골') {
                const spacing = 450;
                
                const runnerKey = `러너-${wall.steelThickness}-${wall.steelLength}`;
                if (!groupedBySteel[runnerKey]) {
                    groupedBySteel[runnerKey] = {
                        type: '러너',
                        thickness: wall.steelThickness,
                        length: wall.steelLength,
                        count: 0
                    };
                }
                let runnerPieces = Math.ceil(wall.width / wall.steelLength) * 2;
                runnerPieces *= (wall.faceDirection === '양면' ? 2 : 1);
                groupedBySteel[runnerKey].count += Math.ceil(runnerPieces * (1 + currentLossRate));
                
                const studKey = `스터드-${wall.steelThickness}-${wall.steelLength}`;
                if (!groupedBySteel[studKey]) {
                    groupedBySteel[studKey] = {
                        type: '스터드',
                        thickness: wall.steelThickness,
                        length: wall.steelLength,
                        count: 0
                    };
                }
                const studCount = Math.floor(wall.width / spacing) + 1;
                const piecesPerStud = Math.ceil(wall.height / wall.steelLength);
                let totalStud = studCount * piecesPerStud;
                totalStud *= (wall.faceDirection === '양면' ? 2 : 1);
                groupedBySteel[studKey].count += Math.ceil(totalStud * (1 + currentLossRate));
            }
        }
    });
    
    // 석고보드 출력 (한 줄로)
    text += `[석고보드]\n`;
    Object.keys(groupedByType).forEach(key => {
        const board = groupedByType[key];
        text += `${board.type} ${board.size} ${board.thickness} - ${board.totalBoards}장\n`;
    });
    
    // 목자재 출력 (한 줄로)
    if (Object.keys(groupedByWood).length > 0) {
        text += `\n[목자재]\n`;
        Object.keys(groupedByWood).forEach(key => {
            const wood = groupedByWood[key];
            text += `${wood.name}`;
            if (wood.size) {
                text += ` ${wood.size}`;
            }
            text += ` - ${wood.count}개\n`;
        });
    }
    
    // 경량철골 출력 (한 줄로)
    if (Object.keys(groupedBySteel).length > 0) {
        text += `\n[경량철골]\n`;
        Object.keys(groupedBySteel).forEach(key => {
            const steel = groupedBySteel[key];
            text += `${steel.type} ${steel.thickness}mm ${steel.length}mm - ${steel.count}개\n`;
        });
    }
    
    return text;
}


[2] shareToKakao() - 카카오톡 공유 메인 함수
========================================
async function shareToKakao() {
    closeShareModal();
    
    // 텍스트 요약 생성
    const textSummary = generateSummaryText();
    
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // 모바일에서 Web Share API 시도
    if (isMobile && navigator.share) {
        try {
            // 먼저 클립보드에 복사
            if (navigator.clipboard) {
                await navigator.clipboard.writeText(textSummary);
            }
            
            // Web Share API 호출
            await navigator.share({
                text: textSummary
            });
            showToast('✅ 카카오톡으로 전송되었습니다!');
            return;
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error('Web Share 실패:', error);
                // Web Share 실패 시 클립보드만 사용
            }
        }
    }
    
    // PC 또는 Web Share 실패 시: 클립보드에 복사
    copyToClipboard(textSummary);
}


[3] copyToClipboard() - 클립보드 복사 함수
========================================
function copyToClipboard(text) {
    if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
            showToast('📋 클립보드에 복사되었습니다!\n카카오톡에 붙여넣기 하세요.');
            
            // 복사된 내용 확인용 로그
            console.log('복사된 텍스트:', text);
        }).catch((err) => {
            console.error('클립보드 복사 실패:', err);
            fallbackCopy(text);
        });
    } else {
        fallbackCopy(text);
    }
}


[4] fallbackCopy() - 대체 복사 방법
========================================
function fallbackCopy(text) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    
    try {
        document.execCommand('copy');
        showToast('📋 클립보드에 복사되었습니다!\n카카오톡에 붙여넣기 하세요.');
        console.log('복사된 텍스트:', text);
    } catch (err) {
        console.error('복사 실패:', err);
        alert('📋 복사 실패\n\n' + text);
    }
    
    document.body.removeChild(textarea);
}


[5] shareSMS() - 문자 전송 함수
========================================
function shareSMS() {
    closeShareModal();
    
    // 텍스트 요약 생성
    const textSummary = generateSummaryText();
    
    // 문자 앱 열기
    const smsUrl = `sms:?body=${encodeURIComponent(textSummary)}`;
    window.location.href = smsUrl;
    
    showToast('💌 문자 앱이 열립니다!');
}


[6] shareEmail() - 이메일 전송 함수
========================================
function shareEmail() {
    closeShareModal();
    
    // 텍스트 요약 생성
    const textSummary = generateSummaryText();
    
    // 이메일 앱 열기
    const subject = encodeURIComponent(`${currentSiteName} - 석고보드 각재 산출내역`);
    const body = encodeURIComponent(textSummary);
    const mailtoUrl = `mailto:?subject=${subject}&body=${body}`;
    window.location.href = mailtoUrl;
    
    showToast('📧 이메일 앱이 열립니다!');
}


[7] showToast() - 토스트 메시지 표시 함수
========================================
function showToast(message) {
    let toast = document.getElementById('toast');
    if (!toast) {
        toast = document.createElement('div');
        toast.className = 'toast';
        toast.id = 'toast';
        document.body.appendChild(toast);
    }
    
    toast.innerHTML = message.replace(/\n/g, '<br>');
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, 4000);
}


========================================
현재 문제점 및 해결 방안
========================================

[문제] 
카카오톡 공유 시 산출 내용 대신 URL이 전송됨

[가능한 원인]
1. Web Share API가 text 대신 현재 페이지 URL을 공유
2. generateSummaryText() 함수에서 URL이 포함되고 있음
3. 브라우저의 공유 기능이 메타 태그의 URL을 우선 사용

[해결 방안]
1. console.log로 textSummary 내용 확인
2. Web Share API 대신 다른 방법 시도
3. 메타 태그 확인 및 수정

========================================



